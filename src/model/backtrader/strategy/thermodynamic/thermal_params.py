"""
热力学参数计算模块
提供热力学参数（炉温、铁块温度、导热系数、筹码峰）的计算接口

核心概念：
- 所有热力学参数都在本模块计算，包括筹码峰（燃料）
- 每个参数都是根据上一个参数进行计算的（状态依赖）
"""
from typing import Dict, Optional
from abc import ABC, abstractmethod
import pandas as pd
from model.backtrader.strategy.thermodynamic.chip_peak import ChipPeak


class ThermalParamsCalculator(ABC):
    """
    热力学参数计算接口
    
    实现此接口以提供自定义的热力学参数计算算法
    
    重要概念：
    - 所有热力学参数都在本接口中计算，包括筹码峰（燃料）
    - 每个参数都是根据上一个参数进行计算的（状态依赖）
    - 这是一个动态演变的过程
    """
    
    @abstractmethod
    def calculate(
        self,
        df: pd.DataFrame,
        previous_params: Optional[Dict] = None,
        price_step: float = 0.01,
        num_segments: int = 100
    ) -> Dict:
        """
        计算热力学核心参数（状态依赖计算）
        
        参数:
        - df: 完整历史数据 DataFrame，必须包含以下列：
            - 'open': 开盘价（每个时间段的开盘价格）
            - 'high': 最高价（每个时间段的最高价格）
            - 'low': 最低价（每个时间段的最低价格）
            - 'close': 收盘价（每个时间段的收盘价格）
            - 'volume': 成交量（每个时间段的成交数量，单位：手或股）
            
            数据说明：
            - 传入所有可用的历史数据（完整数据集）
            - 可以是分时数据（5分钟、15分钟、30分钟、60分钟等）
            - 可以是日线数据
            - 每行代表一个时间段（一个K线）
            - 计算函数内部按需使用（可以使用最近1天、2天、3天等）
        - previous_params: 上一个状态的热力学参数（必需，首次计算时传入空字典或None）
            {9
                'temperature': 上一个炉温
                'iron_temperature': 上一个铁块温度
                'thermal_conductivity': 上一个导热系数
                'chip_peak': 上一个筹码峰（ChipPeak 对象或字典）
            }
        - price_step: 价格步长（固定为0.01元，即一分钱）
            固定值：0.01（一分钱）
        
        - num_segments: 价格分段数量（默认100，可调整）
            作用：将价格范围 [0, 最高价] 分成多少份
            默认值：100
            说明：
                - 可以根据需要调整为更多份（如200、500等）
                - 份数越多，价格区间越精细，但计算量也越大
                - 建议范围：100-500
            
            价格区间划分规则：
            ============================================
            1. 价格步长固定为 0.01元（一分钱）
            2. 根据当前最高价格，将价格范围 [0, 最高价] 分成 N 份
               - 默认 N = 100（可调整，建议100或更多）
               - 每份的宽度 = 最高价 / N
            3. 每份内部再按 0.01元 的步长细分
               - 例如：最高价=10元，分成100份，每份=0.1元
               - 每份内部有 0.1/0.01 = 10 个细粒度区间
               - 总区间数 = 100 * 10 = 1000 个区间
            
            示例：
            ------------
            假设当前最高价 = 5.0元，分成100份：
            - 每份宽度 = 5.0 / 100 = 0.05元
            - 每份内部细分数 = 0.05 / 0.01 = 5 个区间
            - 总区间数 = 100 * 5 = 500 个区间
            - 价格范围：[0.00, 0.01, 0.02, ..., 4.99, 5.00]
            
            假设当前最高价 = 10.0元，分成100份：
            - 每份宽度 = 10.0 / 100 = 0.1元
            - 每份内部细分数 = 0.1 / 0.01 = 10 个区间
            - 总区间数 = 100 * 10 = 1000 个区间
            
            假设当前最高价 = 50.0元，分成100份：
            - 每份宽度 = 50.0 / 100 = 0.5元
            - 每份内部细分数 = 0.5 / 0.01 = 50 个区间
            - 总区间数 = 100 * 50 = 5000 个区间
            
            计算方式（区间合并法）：
            ============================================
            推荐使用"价格步长 + 区间合并"的方式计算筹码峰：
            
            1. 使用 price_step=0.01 定义细粒度价格区间（一分钱一个区间）
            2. 根据当前最高价，确定价格范围 [0, 最高价]
            3. 将价格范围分成100份（或更多份），每份内部按0.01元细分
            4. 对于每个K线，将其成交量按比例分配到 [low, high] 价格范围内的所有细粒度区间
            
            优势：
            - 固定步长0.01元，保证精度一致
            - 根据最高价动态调整区间数量，适应不同价格水平的股票
            - 区间合并法更准确地反映筹码的真实分布
        
        返回:
        参数字典：
        {
            'temperature': 炉温 T（当前股价）- 根据上一个炉温计算
            'iron_temperature': 铁块温度 VWAP（成交均价）- 根据上一个铁块温度计算
            'thermal_conductivity': 导热系数 λ（单位成交量带来的涨幅）- 根据上一个导热系数计算
            'chip_peak': 筹码峰（燃料）- ChipPeak 对象 - 根据上一个筹码峰计算
        }
        
        重要：
        - 所有四个参数都是根据上一个状态计算的（状态依赖）
        - df 传入所有历史数据，计算函数内部按需使用（可以使用最近1天、2天、3天等）
        - 根据传入的数据和上一个状态，计算出新的参数
        - 如果 previous_params 为 None 或空字典，表示首次计算，需要初始化
        """
        pass
